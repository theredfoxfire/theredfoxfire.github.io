<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
  <script src="javascripts/main.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  <title>Javascript operator '==' VS '==='</title>
</head>

<body>
  <header>
    <div class="inner">
      <h1><a href="http://theredfoxfire.github.io/">Hasan Setiawan</a></h1>
      <h2>Write, write, write give your wings on code!</h2>
      <a href="https://github.com/theredfoxfire" class="button"><small>Follow me on</small> GitHub</a>
    </div>
  </header>

  <div id="content-wrapper">
    <div class="inner clearfix">
      <section id="main-content">
        <h2>Javascript operator '==' VS '==='</h2>
        <p>
          The identity (===) operator behaves identically to the equality (==)
          operator except no type conversion is done, and the types must be the same to be considered equal.
        </p>
        <p>
          The == operator will compare for equality after doing any necessary type conversions.
          The === operator will not do the conversion, so if two values are not the same type === will simply return false. Both are equally quick.
        </p>
        <p>
          JavaScript has two sets of equality operators: === and !==, and their evil
          twins == and !=. The good ones work the way you would expect.
          If the two operands are of the same type and have the same value,
          then === produces true and !== produces false. The evil twins do the
          right thing when the operands are of the same type, but if they are of different types,
          they attempt to coerce the values. the rules by which they do that are complicated and
          unmemorable. These are some of the interesting cases:
        </p>
        <p>
          <pre>
            <code>
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
            </code>
          </pre>
        </p>
        <p>
          The lack of transitivity is alarming. My advice is to never use the evil twins. Instead,
          always use === and !==. All of the comparisons just shown produce false with the === operator.
          Update:
        </p>
        <p>
          <pre>
            <code>
var a = [1,2,3];
var b = [1,2,3];

var c = { x: 1, y: 2 };
var d = { x: 1, y: 2 };

var e = "text";
var f = "te" + "xt";

a == b            // false
a === b           // false

c == d            // false
c === d           // false

e == f            // true
e === f           // true
            </code>
          </pre>
        </p>
        <p>
          A good point was brought up by @Casebash in the comments and in @Phillipe Laybaert's
          answer concerning reference types. For reference types == and === act consistently with one another (except in a special case).
        </p>
        <p>
          The special case is when you compare a literal with an object that evaluates to the same
          literal, due to its toString or valueOf method. For example, consider the comparison of a string literal with a string object created by the String constructor.
        </p>
        <p>
          <pre>
            <code>
"abc" == new String("abc")    // true
"abc" === new String("abc")   // false
            </code>
          </pre>
        </p>
        <p>
          Here the == operator is checking the values of the two objects and returning true,
          but the === is seeing that they're not the same type and returning false.
          Which one is correct? That really depends on what you're trying to compare.
          My advice is to bypass the question entirely and just don't use the String constructor
          to create string objects.
        </p>
      </section>

      <aside id="sidebar">


        <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        <h3>

        </h3>
      </aside>
    </div>
  </div>


</body>
</html>
