<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  <title># 1 # S.O.L.I.D Object Oriented Design</title>
</head>

<body>
  <header>
    <div class="inner">
      <h1><a href="http://theredfoxfire.github.io/">Hasan Setiawan</a></h1>
      <h2>Write, write, write give your wings on code!</h2>
      <a href="https://github.com/theredfoxfire" class="button"><small>Follow me on</small> GitHub</a>
    </div>
  </header>

  <div id="content-wrapper">
    <div class="inner clearfix">
      <section id="main-content">
        <h2># 1 # S.O.L.I.D Object Oriented Design</h2>
        <p>
            In PHP OOP we already know about Dependency Injection, or some design pattern like Factory,
            singleton. And how about SOLID?
        </p>
        <p>
            SOLID stands for<br><br>

            Single responsibility principle<br>
            Open closed principle<br>
            Liskov substitution principle<br>
            Interface segregation principle<br>
            Dependency inversion principle<br>
        </p>
        <h3># 1 # Single responsibility principle</h3>
        <p>
            Single Responsibility Principle or SRP states that every class should have a single responsibility. There should never be more than one reason for a class to change.
            <br><br>
            Just because you can add everything you want into your class doesnâ€™t mean that you should. Thinking in term of responsibilities will help you design your application better. Ask yourself whether the logic you are introducing should live in this class or not. Using layers in your application helps a lot. Split big classes in smaller ones, and avoid god classes. Last but not least, write straightforward comments. If you start writing comments such as in this case, but if, except when, or, then you are doing it wrong.
        </p>

        <p>
              <pre>
              <code>
                  // Single Responsibility Principle Violation
                  class Report
                  {
                      public function getTitle()
                      {
                          return 'Report Title';
                      }
                      public function getDate()
                      {
                          return '2016-04-21';
                      }
                      public function getContents()
                      {
                          return [
                              'title' => $this->getTitle(),
                              'date' => $this->getDate(),
                          ];
                      }
                      public function formatJson()
                      {
                          return json_encode($this->getContents());
                      }
                  }
                  

                  // Refactored
                  class Report
                  {
                      public function getTitle()
                      {
                          return 'Report Title';
                      }
                      public function getDate()
                      {
                          return '2016-04-21';
                      }
                      public function getContents()
                      {
                          return [
                              'title' => $this->getTitle(),
                              'date' => $this->getDate(),
                          ];
                      }
                  }


                  interface ReportFormattable
                  {
                      public function format(Report $report);
                  }
                  class JsonReportFormatter implements ReportFormattable
                  {
                      public function format(Report $report)
                      {
                          return json_encode($report->getContents());
                      }
                  }
              </code>
          </pre>
        </p>
      </section>

      <aside id="sidebar">


        <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        <h3>
          
        </h3>
      </aside>
    </div>
  </div>


</body>

</html>
