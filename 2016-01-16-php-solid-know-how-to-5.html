<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

  <title># 5 # S.O.L.I.D Object Oriented Design</title>
</head>

<body>
  <header>
    <div class="inner">
      <h1><a href="http://theredfoxfire.github.io/">Hasan Setiawan</a></h1>
      <h2>Write, write, write give your wings on code!</h2>
      <a href="https://github.com/theredfoxfire" class="button"><small>Follow me on</small> GitHub</a>
    </div>
  </header>

  <div id="content-wrapper">
    <div class="inner clearfix">
      <section id="main-content">
        <h2># 5 # S.O.L.I.D Object Oriented Design</h2>
        <p>
            In PHP OOP we already know about Dependency Injection, or some design pattern like Factory,
            singleton. And how about SOLID?
        </p>
        <p>
            SOLID stands for<br><br>

            Single responsibility principle<br>
            Open closed principle<br>
            Liskov substitution principle<br>
            Interface segregation principle<br>
            Dependency inversion principle<br>
        </p>
        <h3># 5 # Dependency inversion principle</h3>
        <p>
            This principle states that high level modules should not depend on low level modules. High level modules should never change and should be decoupled (seperated) from low level modules that could be changed on a daily basis.
            <br><br>
          In software engineering, the adapter pattern is a software design pattern that allows the interface of an existing class to be used from another interface.
          It is often used to make existing classes work with others without modifying their source code.
        </p>
        <p>

        </p>

        <p>
            <pre>
              <code>
                // EmailTokenInformationProvider
                interface EmailTokenInformationProvider
                {
                    /**
                     * @param string $emailToken
                     * @return DateTimeImmutable
                     */
                    public function getCreationTime($emailToken);
                }


                // UserEmailTokenInformationProvider
                class UserEmailTokenInformationProvider implements EmailTokenInformationProvider
                {
                    private $userModel;

                    public function __construct(UserModel $userModel)
                    {
                      $this->userModel = $userModel;
                    }

                    public function getCreationTime($emailToken)
                    {
                      $userRow = $this->userModel->getByEmailToken($emailToken);

                      if (empty($userRow)) {
                          throw new EmailTokenNotFound($emailToken);
                      }

                      $emailTokenCreatedAt =
                          new DateTimeImmutable($userRow['email_token_created_at']);

                      return $emailTokenCreatedAt;
                    }
                }
              </code>
          </pre>
        </p>

        <p>
            How to correctly instantiate our EmailTokenService:
        </p>

        <p>
            <pre>
              <code>
                  // App
                  $userModel = new UserModel();
                  $userEmailTokenInformationProvider = new UserEmailTokenInformationProvider($userModel);
                  $emailTokenService = new EmailTokenService($userEmailTokenInformationProvider);

                  $isEmailTokenValid = $emailTokenService->isEmailTokenValid($emailToken);


              </code>
          </pre>
        </p>
      </section>

      <aside id="sidebar">


        <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.<br><br><hr/><a action="action" onclick="window.history.go(-1); return false;" href="#">Back</a></p>
        <h3>
          
        </h3>
      </aside>
    </div>
  </div>


</body>

</html>
